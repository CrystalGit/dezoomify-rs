use serde::Deserialize;

use crate::dezoomer::Vec2d;

#[derive(Debug, Deserialize, PartialEq)]
pub struct ImageProperties {
    #[serde(rename = "WIDTH", default)]
    pub width: u32,
    #[serde(rename = "HEIGHT", default)]
    pub height: u32,
    #[serde(rename = "TILESIZE", default)]
    pub tile_size: u32,
    #[serde(rename = "NUMTILES", default)]
    pub num_tiles: u32,
}

impl ImageProperties {
    fn size(&self) -> Vec2d {
        Vec2d {
            x: self.width,
            y: self.height,
        }
    }
    fn tile_size(&self) -> Vec2d {
        Vec2d {
            x: self.tile_size,
            y: self.tile_size,
        }
    }

    /// Trying to detect and fix obviously invalid NUMTILES values such
    /// as the ones generated by IIPSRV in versions <= 1.1
    /// See: https://github.com/ruven/iipsrv/issues/86
    fn real_num_tiles(&self) -> u32 {
        let Vec2d { x, y } = self.size().ceil_div(self.tile_size());
        if self.num_tiles <= x * y {
            // self.num_tiles seems not to be taking all levels into accounts
            let mut size = self.size();
            let mut num_tiles = 1;
            while size.x.max(size.y) > self.tile_size {
                let tiles = size.ceil_div(self.tile_size());
                num_tiles += tiles.x * tiles.y;
                size = size / 2;
            }
            num_tiles
        } else { self.num_tiles }
    }

    pub fn levels(&self) -> impl Iterator<Item = ZoomLevelInfo> {
        let mut remaining_tiles = i64::from(self.real_num_tiles());
        let mut size = self.size();
        let tile_size = self.tile_size();
        std::iter::from_fn(move || {
            if remaining_tiles <= 0 {
                None
            } else {
                let Vec2d {
                    x: tiles_x,
                    y: tiles_y,
                } = size.ceil_div(tile_size);
                remaining_tiles -= i64::from(tiles_x) * i64::from(tiles_y);
                let tiles_before = remaining_tiles as u32;
                let lvl = ZoomLevelInfo {
                    tiles_before,
                    tile_size,
                    size,
                };
                size = size.ceil_div(Vec2d { x: 2, y: 2 });
                Some(lvl)
            }
        })
    }
}

pub struct ZoomLevelInfo {
    pub size: Vec2d,
    pub tile_size: Vec2d,
    pub tiles_before: u32,
}

impl ZoomLevelInfo {
    pub fn tile_group(&self, pos: Vec2d) -> u32 {
        let num_tiles_x = (self.size.ceil_div(self.tile_size)).x;
        (self.tiles_before + pos.x + pos.y * num_tiles_x) / 256
    }
}

#[test]
fn test_deserialize() {
    let src = r#"
        <IMAGE_PROPERTIES
            WIDTH="4000" HEIGHT="2559"
            NUMTILES="217"
            NUMIMAGES="1"
            VERSION="1.8"
            TILESIZE="256" />"#;
    let props: ImageProperties = serde_xml_rs::from_str(src).unwrap();
    assert_eq!(props.width, 4000);
    assert_eq!(props.height, 2559);
    assert_eq!(props.tile_size, 256);
    assert_eq!(props.num_tiles, 217);
}

#[test]
fn test_real_num_tiles() {
    // An image with 3 levels: 10x5 6x2 and 2x2
    let props = ImageProperties {
        width: 10,
        height: 5,
        tile_size: 3,
        num_tiles: 4 * 2,
    };
    assert_eq!(props.real_num_tiles(), 11);
}
